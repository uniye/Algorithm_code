# 다양한 형태의 전체 탐색
- for 반복문으로 배열을 단순히 살펴보는 것으로는 문제를 풀 수 없음.
- 이를 위한 그래프 탐색 알고리즘 = 깊이우선탐색, 너비 우선 탐색
# 깊이 우선 탐색과 너비 우선 탐색
- 너비 우선 탐색: 깊이가 얕은 순서대로 왼쪽부터 차근차근 정점 탐색, 한획에 모든 정점을 돌아다닐 수 없음.
- 깊이 우선 탐색: 최대한 왼쪽으로 깊게 정점을 탐색, 한획에 모든 정점을 돌아다닐 수 있음. 
- 어디에 어떻게 적용시키는가? 
    1. 정점 A는 몇 개의 정점과 직접 또는 간접적으로 연결되어있는가?
    2. 정점 A에서 정점 J로 이동하는 것이 가능한가? 가능하다면 어떤 방식으로 이동하는가?
    3. 위에서 아래로만 이동할 수 있다고 할 때 정점 A부터 순서대로 이동할 수 없는 때까지 이동한다면 이동 방식은 몇 가지가 있는가?
    - 1번과 2번은 방향이 정해져 있지 않기에 무향 그래프, 3번은 이동 방향이 정해져 있기에 유향 그래프다.
# 그래프와 상황
- 어떻게 현실 상황과 그래프 탐색 순서 연결? => 변환할 수 없는 상황에 탐색을 적용할 순 없음. 그러나 대부분은 가능
- 너비 우선 탐색은 스택, 큐, 리스트, 배열로 쉽게 구현
- 깊이 우선 탐색은 재귀 함수 사용해 쉽게 구현
- 최고 우선 탐색 - 정점A에서 부터의 거리가 짧은 순서로 탐색하는 방법 : 거리가 가장 짧은 것이라는 경우에 사용
# 다익스트라 알고리즘
- 최고 우선 탐색을 사용하는 대표적인 알고리즘
- 루프가 존재하므로 한 번 탐색했던 정점은 더이상 탐색하지 않는다는 규칙을 추가함.
# 가지 치기
- 한 번 탐색했던 정점은 더이상 탐색하지 않는 방법, 추가적으로 (ex)10번 이동하면 탐색 중단하는 방법 => 불필요한 탐색을 줄이는 방법
- 가지 치기를 잘못하면 잘못된 정답이 될 수 있음.
# 탐색과 구현
- 어떻게 탐색을 구현할지 생각해보자
# 깊이 우선 탐색
- 메모리에 후입선출(stack)방식으로 정점을 저장
# 너비 우선 탐색
- 깊이 우선 탐색과 다른 점 
    - 이전 정점으로 돌아올 필요가 없다
    - 가까운 순서로 탐색하므로 나중에 발견한 정점은 나중에 탐색
- 가까운 순으로 탐색
- 메모리에 선입선출(queue)방식으로 정점 저장
# 자료 구조
- 자료를 저장하는 방법
## 스택
- 깊이 우선 탐색에 사용, 선입후출
- 재귀함수도 내부적으로 스택을 사용
## 큐
- 너비 우선 탐색에 사용, 선입선출
## 데큐
- 스택과 큐를 조합한 것
# 재귀 함수
- 스스로를 호출하는 함수
- ```cpp
    int fib(int a)
    {
        if(a <= 1) return 1;
        return fib(a - 1) + fib(a - 2);
    }
  ```
# 깊이 우선 탐색 구현
- 스택을 사용한 깊이 우선 탐색은 전후처리를 넣어야 하므로 번잡한 코드가 된다.
- 재귀함수 사용하는 것이 좋음
- int 자료형으로 상태를 나타낼 때 최댓값을 찾는 코드
    - ```cpp
      int dfs(int now)
      {
        if(현재 상태 now가 끝나는 조건) return 현재 상태 now의 값;
        int ret = -1;
        for(int i = 0; i < 다음 상태 개수; i++)
        {
          int next = i번째 다음 상태;
          if(next가 조건을 만족하는 경우) ret = max(dfs(next), ret);
        }
      }
      ```
# 너비 우선 탐색 구현
- 코드
    - ```cpp
      Queue<T> q = new Queue<T>();
      q.Enqueue(초기 상태);
      while(q.Count != 0)
      {
            T now = q.Dequeue();
            현재 상태 처리
            for(int i = 0; i < 다음 상태 개수; i++)
            {
                T next = i번째 다음 상태;
                if(next를 방문했었는지 판정)
                    q.Enqueue(next);
            }
      }
    ```
# 깊이 우선 탐색과 너비 우선 탐색의 차이점
- 깊이 우선 탐색을 사용하면 좋은 경우
    - 모든 경로를 탐색하고 결과를 확인해야 하는 경우
    - 문자열 등을 탐색할 때 "사전 순서로 앞에오는 것"처럼 앞부터 검색해서 찾는 것이 빠른 경우
- 너비 우선 탐색을 사용하면 좋은 경우
    - 시작 지점에서 가장 가까운 것을 구하고 싶은 경우
    - 탐색 범위 자체는 넓지만 어느정도 근처에 구하고 싶은 해가 존재하는 것을 알고 있는 경우
    - 탐색 범위가 굉장히 넓으며 깊이 우선 탐색을 사용할 때는 스택이 대량으로 사용되는 경우


